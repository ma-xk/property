generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id            String     @id @default(cuid())
  name          String?
  email         String     @unique
  emailVerified DateTime?
  image         String?
  password      String?
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt
  accounts      Account[]
  people        Person[]
  places        Place[]
  properties    Property[]
  deals         Deal[]
  sessions      Session[]
  taxPayments   TaxPayment[]
  millRateHistories MillRateHistory[]
  propertyValuationHistories PropertyValuationHistory[]
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

enum PlaceKind {
  STATE
  COUNTY
  TOWN
  UT
  CITY
}

enum DealStage {
  LEAD
  UNDER_CONTRACT
  DUE_DILIGENCE
  CLOSING
  WON
  LOST
}

enum DealStatus {
  ACTIVE
  ON_HOLD
  CANCELLED
}

model Place {
  id                     String     @id @default(cuid())
  name                   String
  kind                   PlaceKind
  state                  String?
  country                String     @default("United States")
  description            String?
  userId                 String
  createdAt              DateTime   @default(now())
  updatedAt              DateTime   @updatedAt
  
  // Hierarchical relationships (matching existing migration)
  parentId               String?
  parent                 Place?     @relation("PlaceHierarchy", fields: [parentId], references: [id])
  children               Place[]    @relation("PlaceHierarchy")
  
  // Direct relationships for easier querying
  countyId               String?
  county                 Place?     @relation("CountyPlaces", fields: [countyId], references: [id])
  placesInCounty         Place[]    @relation("CountyPlaces")
  
  statePlaceId           String?
  statePlace             Place?     @relation("StatePlaces", fields: [statePlaceId], references: [id])
  placesInState          Place[]    @relation("StatePlaces")
  
  // Tax-related fields
  assessmentDay          Int?
  assessmentMonth        Int?
  lateInterestRate       Decimal?
  taxDueDay              Int?
  taxDueMonth            Int?
  taxNotes               String?
  taxOfficePhone         String?
  taxPaymentAddress      String?
  taxPaymentWebsite      String?
  ceoEmail               String?
  ceoName                String?
  ceoPhone               String?
  plumbingInspectorEmail String?
  plumbingInspectorName  String?
  plumbingInspectorPhone String?
  zoningOfficeAddress    String?
  zoningOfficePhone      String?
  zoningOfficeWebsiteUrl String?
  millRate               Decimal?
  
  user                   User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  properties             Property[]
  deals                  Deal[]
  millRateHistories      MillRateHistory[]

  @@unique([name, kind, parentId, userId])
  @@index([userId])
  @@index([parentId])
  @@index([countyId])
  @@index([statePlaceId])
}

model Person {
  id                       String     @id @default(cuid())
  name                     String
  email                    String?
  phone                    String?
  company                  String?
  role                     String?
  notes                    String?
  userId                   String
  createdAt                DateTime   @default(now())
  updatedAt                DateTime   @updatedAt
  user                     User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  dealsAsBuyerAgent        Deal[]     @relation("DealBuyerAgent")
  dealsAsSellerAgent       Deal[]     @relation("DealSellerAgent")
  dealsAsSeller            Deal[]     @relation("DealSeller")
  dealsAsTitleCompany      Deal[]     @relation("DealTitleCompany")

  @@unique([name, userId])
  @@index([userId])
}

model Deal {
  id                   String     @id @default(cuid())
  name                 String
  description          String?
  dealStage            DealStage  @default(LEAD)
  dealStatus           DealStatus @default(ACTIVE)
  targetClosingDate    DateTime?
  dealNotes            String?
  
  // Property information
  streetAddress        String?
  city                 String?
  state                String?
  zipCode              String?
  acres                Decimal?
  zoning               String?
  
  // Deal financials
  askingPrice          Decimal?
  offerPrice           Decimal?
  earnestMoney         Decimal?
  estimatedClosingCosts Decimal?
  
  // Purchase transaction details
  purchasePrice        Decimal?
  closingDate          DateTime?
  
  // Financing details
  financingTerms       String?
  financingType        String?
  
  // Closing costs
  titleSettlementFee   Decimal?
  titleExamination     Decimal?
  ownersPolicyPremium  Decimal?
  recordingFeesDeed    Decimal?
  stateTaxStamps       Decimal?
  eRecordingFee        Decimal?
  realEstateCommission Decimal?
  
  // Relationships
  sellerId             String?
  sellerAgentId        String?
  buyerAgentId         String?
  titleCompanyId       String?
  placeId              String?
  
  // Promotion tracking
  promotedToPropertyId String? @unique
  promotedAt           DateTime?
  
  userId               String
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt
  
  // Relations
  seller               Person?   @relation("DealSeller", fields: [sellerId], references: [id])
  sellerAgent          Person?   @relation("DealSellerAgent", fields: [sellerAgentId], references: [id])
  buyerAgent           Person?   @relation("DealBuyerAgent", fields: [buyerAgentId], references: [id])
  titleCompany         Person?   @relation("DealTitleCompany", fields: [titleCompanyId], references: [id])
  place                Place?    @relation(fields: [placeId], references: [id])
  user                 User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  promotedProperty     Property? @relation("DealToProperty", fields: [promotedToPropertyId], references: [id])
  
  @@index([userId])
  @@index([dealStage])
  @@index([dealStatus])
  @@index([placeId])
  @@index([sellerId])
  @@index([sellerAgentId])
  @@index([buyerAgentId])
  @@index([titleCompanyId])
  @@index([promotedToPropertyId])
}

model Property {
  id                   String    @id @default(cuid())
  name                 String?
  description          String?
  type                 String?
  bedrooms             Int?
  bathrooms            Decimal?
  squareFeet           Int?
  rent                 Decimal?
  deposit              Decimal?
  available            Boolean   @default(true)
  userId               String
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt
  
  // Property characteristics
  acres                Decimal?
  zoning               String?
  
  // Address
  streetAddress        String?
  city                 String?
  state                String?
  zipCode              String?
  placeId              String?
  
  // Ongoing financial management
  balloonDueDate       DateTime?
  propertyTaxProration Decimal?
  
  // Valuation information
  assessedValue        Decimal?
  assessmentNotes      String?
  lastAssessmentDate   DateTime?
  marketValue          Decimal?
  
  // Relationships
  place                Place?    @relation(fields: [placeId], references: [id])
  user                 User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  taxPayments          TaxPayment[]
  valuationHistories   PropertyValuationHistory[]
  originalDeal         Deal? @relation("DealToProperty")

  @@index([userId])
  @@index([placeId])
}

model TaxPayment {
  id          String   @id @default(cuid())
  year        Int      // Tax year (e.g., 2024)
  amount      Decimal  // Payment amount
  paymentDate DateTime // Date when payment was made
  notes       String?  // Optional notes about the payment
  
  // Relationships
  propertyId  String
  property    Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  
  userId      String   // For security - ensure user can only access their payments
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@unique([propertyId, year]) // One payment per property per year
  @@index([propertyId])
  @@index([userId])
}

model MillRateHistory {
  id        String   @id @default(cuid())
  year      Int      // Tax year (e.g., 2024)
  millRate  Decimal  // Mill rate for this year
  notes     String?  // Optional notes about the mill rate
  
  // Relationships
  placeId   String
  place     Place    @relation(fields: [placeId], references: [id], onDelete: Cascade)
  
  userId    String   // For security - ensure user can only access their mill rates
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@unique([placeId, year]) // One mill rate per place per year
  @@index([placeId])
  @@index([userId])
}

model PropertyValuationHistory {
  id                 String   @id @default(cuid())
  year               Int      // Assessment year (e.g., 2024)
  assessedValue      Decimal? // Assessed value for this year
  marketValue        Decimal? // Market value for this year
  assessmentDate     DateTime? // Date of assessment
  assessmentNotes    String?  // Notes about this assessment
  
  // Relationships
  propertyId         String
  property           Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  
  userId             String   // For security - ensure user can only access their valuations
  user               User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
  
  @@unique([propertyId, year]) // One valuation per property per year
  @@index([propertyId])
  @@index([userId])
}
